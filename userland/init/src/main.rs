// userland/init/src/main.rs
// GuardBSD init process: sets up system and spawns services

#![no_std]
#![no_main]

use gbsd::*;

const LOGD_CONFIG: &[u8] = b"# Logd Configuration File
# Automatically generated by init

log_file = /var/log/kernel.log
max_size = 524288
rotate_keep = 3
flush_interval_ms = 100
level = info
\0";

#[no_mangle]
pub extern "C" fn _start() -> ! {
    init_main()
}

fn init_main() -> ! {
    // FIRST: Ensure basic directories exist
    println("[INIT] creating /etc");
    ensure_directories();

    // SECOND: Create default logd configuration if missing
    println("[INIT] creating default logd.conf");
    create_default_config();

    // THIRD: Spawn logd FIRST (critical dependency)
    println("[INIT] starting logd");
    spawn(b"/bin/logd\0");

    // Wait for logd to be online
    println("[INIT] waiting for logd registration...");
    wait_for_logd();

    // FOURTH: Spawn servers in dependency order
    println("[INIT] starting vfs");
    spawn(b"/bin/vfs\0");

    println("[INIT] starting ramfs");
    spawn(b"/bin/ramfs\0");

    println("[INIT] starting devd");
    spawn(b"/bin/devd\0");

    println("[INIT] starting netd");
    spawn(b"/bin/netd\0");

    println("[INIT] starting netsvc");
    spawn(b"/bin/netsvc\0");

    // FIFTH: Spawn shell last
    println("[INIT] starting gsh");
    spawn(b"/bin/gsh\0");

    // If we get here, something went wrong
    exit(1);
}

fn ensure_directories() {
    // Create /etc directory
    let _ = mkdir(b"/etc\0");
    println("[INIT] creating /var/log");
    let _ = mkdir(b"/var\0");
    let _ = mkdir(b"/var/log\0");
    let _ = mkdir(b"/bin\0");
}

fn create_default_config() {
    let config_path = b"/etc/logd.conf\0";

    // Check if config already exists using stat
    if stat(config_path).is_ok() {
        return; // Config already exists
    }

    // Create default config file
    match open(config_path, O_CREAT | O_WRONLY) {
        Ok(fd) => {
            let _ = write(fd, LOGD_CONFIG);
            let _ = close(fd);
        }
        Err(_) => {
            // Could not create config file, continue anyway
            println("[INIT] WARNING: could not create logd.conf");
        }
    }
}

fn spawn(path: &[u8]) -> ! {
    exec(path);
}

fn wait_for_logd() {
    // For now, just wait a bit and assume logd started
    // In a real implementation, we might poll a status endpoint
    // or wait for a specific log message

    // Simple delay - in practice this would be more sophisticated
    for _ in 0..100000 {
        cpu_relax();
    }
}

fn println(msg: &str) {
    let mut buf = [0u8; 256];
    let mut pos = 0;

    for &b in msg.as_bytes() {
        if pos < buf.len() - 1 {
            buf[pos] = b;
            pos += 1;
        }
    }
    buf[pos] = b'\n';
    pos += 1;

    let _ = write(1, &buf[..pos]); // stdout
}

fn cpu_relax() {
    #[cfg(target_arch = "x86_64")]
    unsafe {
        core::arch::asm!("pause", options(nomem, nostack));
    }

    #[cfg(target_arch = "aarch64")]
    unsafe {
        core::arch::asm!("yield", options(nomem, nostack));
    }
}
